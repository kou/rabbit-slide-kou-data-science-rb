= RubyもApache Arrowで\nデータ処理言語の\n仲間入り

: author
   須藤功平
: institution
   クリアコード
: content-source
   DataScience.rbワークショップ
: date
   2017-05-19
: allotted-time
   20m
: theme
   clear-code

= はじめに

(('tag:center'))
(('tag:large'))
私はRubyが好きだ

(('tag:center'))
(('tag:large'))
だからデータ分析だって\n
Rubyでやりたい

(('tag:center'))
(('note:Rubyよりも向いている言語があるのはわかっているけどさー'))

= Apache Arrow

  * データフォーマットの仕様
  * ↑を扱う実装

= Arrow：解決したい問題

  * 高いデータ交換コスト
  * 重複した最適化実装

= Arrow：文脈

ビッグデータの分析

= ビッグデータの分析

  * いろんなシステムが連携
    * Java実装のもろもろとPythonとR
  * システム間でデータ交換が必要
    * 交換する度にシリアライズ・パース
    * (('wait'))↑に結構CPUと時間を使われる…
    * (('wait'))そんなのより分析処理に使いたい！

= Arrow：解決方針

コストゼロの\n
シリアライズ・\n
パース

= Arrow：コストゼロの実現

  * そのまま使えるフォーマット
    * 例:int8の配列→int8の値を連続配置
    * 1バイトずつずらせば高速アクセス可
  * Arrowのトレードオフ
    * サイズ圧縮よりシリアライズゼロ
    * 参考：Parquetはサイズ圧縮優先

= Arrowがある世界

  * 各システムがサクサク連携
    * 例：PySparkが高速化
    * 理由:Py🡘Javaのデータ交換コスト減
  * Java・Python・R以外も活躍
    * 例：Ruby・Go・Rust・Juliaとか
    * 理由：低コストでデータ交換可能

= ArrowとRuby

チャンス！

= ArrowとRubyとデータ分析

  * RubyがArrowに対応
    * Rubyにデータが回ってくる！
  * 次のステップ
    * できることを増やしていく

= ArrowとRubyの今

  * RubyでArrowを使える！
    * 私が使えるようにしているから！
    * 公式リポジトリーにも入っている\n
      (('note:厳密に言うと違うんだけど公式サポートだと思ってよい'))
    * コミッターにもなった

= 今できること

(('tag:center'))
pandasでデータ生成→書き込み

  # coderay python
  import pyarrow as pa

  df = pd.DataFrame({"a": [1, 2, 3],
                     "b": ["hello", "world", "!"]})
  record_batch = pa.RecordBatch.from_pandas(df)

  with pa.OSFile("/tmp/pandas.arrow", "wb") as sink:
      schema = record_batch.schema
      writer = pa.RecordBatchFileWriter(sink, schema)
      writer.write_batch(record_batch)
      writer.close()

= 今できること

(('tag:center'))
Rubyで読み込み

  # coderay ruby
  require "arrow"

  Input = Arrow::MemoryMappedInputStream
  Reader = Arrow::RecordBatchFileReader
  Input.open("/tmp/pandas.arrow") do |input|
    reader = Reader.new(input)
    reader.each do |record_batch|
      puts("=" * 40)
      puts(record_batch)
    end
  end

= 今できること

(('tag:center'))
NumPyでデータ生成→書き込み

  # coderay python
  import pyarrow as pa
  import numpy as np

  ndarray = np.random.randn(10, 6)
  print(ndarray)
  tensor = pa.Tensor.from_numpy(ndarray)
  with pa.OSFile("/tmp/tensor.arrow", "wb") as sink:
      pa.write_tensor(tensor, sink)

= 今できること

(('tag:center'))
Rubyで読み込み

  # coderay ruby
  require "arrow"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/tensor.arrow") do |input|
    tensor = input.read_tensor(0)
    p tensor.shape # => [10, 6]
  end

= 今できること

(('tag:center'))
GSLオブジェクトに変換

  # coderay ruby
  require "arrow"
  require "arrow-gsl"
  require "pp"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/tensor.arrow") do |input|
    tensor = input.read_tensor(0)
    pp tensor.to_gsl
    # tensor.to_gsl.to_arrow == tensor
  end

= 今できること

(('tag:center'))
NMatrixオブジェクトに変換

  # coderay ruby
  require "arrow"
  require "arrow-nmatrix"
  require "pp"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/tensor.arrow") do |input|
    tensor = input.read_tensor(0)
    pp tensor.to_nmatrix
    # tensor.to_nmatrix.to_arrow == tensor
  end

= 今できること

(('tag:center'))
Numo::NArrayオブジェクトに変換

  # coderay ruby
  require "arrow"
  require "arrow-numo-narray"
  require "pp"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/tensor.arrow") do |input|
    tensor = input.read_tensor(0)
    pp tensor.to_narray
    # tensor.to_narray.to_arrow == tensor
  end

= ここまでのまとめ

  * Arrowが実現したい世界
    * データ交換コストが低い世界
  * RubyとArrowの今
    * ArrowはRubyを公式サポート！
    * Rubyの外の世界とデータ交換可能
    * Rubyの各種ライブラリーとの\n
      相互変換が可能\n
      (('note:（メモリーコピーぐらいのコストで）'))

= ArrowとRubyとこれから

  * Arrow
    * ...
