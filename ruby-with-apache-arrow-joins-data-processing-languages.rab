= RubyもApache Arrowで\nデータ処理言語の\n仲間入り

: author
   須藤功平
: institution
   クリアコード
: content-source
   DataScience.rbワークショップ
: date
   2017-05-19
: allotted-time
   20m
: theme
   clear-code

= はじめに

(('tag:center'))
(('tag:large'))
私はRubyが好きだ

(('tag:center'))
(('tag:large'))
だからデータ分析だって\n
Rubyでやりたい

(('tag:center'))
(('note:Rubyよりも向いている言語があるのはわかっているけどさー'))

= Apache Arrow

  * データフォーマットの仕様

(('tag:center'))
と

  * その仕様を処理する実装

= Arrow：解決したい問題

  * 高いデータ交換コスト
    * →低くしたい
  * 重複した最適化実装
    * →実装を共有したい

= Arrow：文脈

ビッグデータの分析

= ビッグデータの分析

  * いろんなシステムが連携
    * Java実装のもろもろとPythonとR
  * システム間でデータ交換が必要
    * 交換する度にシリアライズ・パース
    * (('wait'))↑に結構CPUと時間を使われる…
    * (('wait'))そんなのより分析処理に使いたい！

= Arrow：解決方針

コストゼロの\n
シリアライズ・\n
パース

= Arrow：コストゼロの実現

  * そのまま使えるフォーマット
    * 例:int8の配列→int8の値を連続配置
    * 1バイトずつずらせば高速アクセス可
  * Arrowのトレードオフ
    * サイズ圧縮よりシリアライズゼロ
    * 参考：Parquetはサイズ圧縮優先

= Arrowがある世界

  * 各システムがサクサク連携
    * 例：PySparkが高速化
    * 理由:Py🡘Javaのデータ交換コスト減
  * Java・Python・R以外も活躍
    * 例：Ruby・Go・Rust・Juliaとか
    * 理由：低コストでデータ交換可能

= ArrowとRuby

チャンス！

= ArrowとRubyとデータ分析

  * RubyがArrowに対応
    * Rubyにデータが回ってくる！
    * →Rubyにもデータ分析の機会が！\n
      (('note:（今はできることは少ないだろうけど…）'))
  * (('wait'))次のステップ
    * できることを増やしていく！
    * →Rubyでもいろいろデータ分析！

= ArrowとRubyの今

  * RubyでArrowを使える！
    * 私が使えるようにしているから！\n
      (('note:コミッターにもなった'))
    * 公式リポジトリーにも入っている\n
      (('note:厳密に言うと違うんだけど公式サポートだと思ってよい'))
  * Rubyでデータを読み書きできる

= 今できること

  * Python・Rとのデータ交換
  * Rubyの各種ライブラリー間での\n
    データ交換

= Arrow：Python

  # coderay python
  # pandasでデータ生成→Arrowで書き込み
  import pyarrow as pa

  df = pd.DataFrame({"a": [1, 2, 3],
                     "b": ["hello", "world", "!"]})
  record_batch = pa.RecordBatch.from_pandas(df)

  with pa.OSFile("/tmp/pandas.arrow", "wb") as sink:
      schema = record_batch.schema
      writer = pa.RecordBatchFileWriter(sink, schema)
      writer.write_batch(record_batch)
      writer.close()

= Arrow：Ruby

  # coderay ruby
  # Rubyでpandasのデータを読み込み
  require "arrow"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/pandas.arrow") do |input|
    reader = Arrow::RecordBatchFileReader.new(input)
    reader.each do |record_batch|
      puts("=" * 40)
      puts(record_batch)
    end
  end

= Feather：R

  # coderay R
  # Rでデータ生成→Featherで書き込み
  library("feather")

  df = data.frame(a=c(1, 2, 3),
                  b=c(1.1, 2.2, 3.3))
  write_feather(df, "/tmp/dataframe.feather")

= Feather：Ruby

  # coderay ruby
  # RubyでRのデータを読み込み
  require "arrow"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/dataframe.feather") do |input|
    reader = Arrow::FeatherFileReader.new(input)
    reader.columns.each do |column|
      puts("#{column.name}: #{column.to_a.inspect}")
    end
  end

= Parquet：Python

  # coderay python
  # Pythonでデータ生成→Parquetで書き込み
  import pandas as pd
  import pyarrow as pa
  import pyarrow.parquet as pq

  df = pd.DataFrame({"a": [1, 2, 3],
                     "b": ["hello", "world", "!"]})
  table = pa.Table.from_pandas(df)
  pq.write_table(table, "/tmp/pandas.parquet")

= Parquet：Ruby

  # coderay ruby
  # RubyでParquet形式のデータを読み込み
  require "arrow"
  require "parquet"

  path = "/tmp/pandas.parquet"
  reader = Parquet::ArrowFileReader.new(path)
  table = reader.read_table
  table.each_column do |column|
    puts("#{column.name}: #{column.to_a.inspect}")
  end

= 対応データ形式まとめ

  * Arrow形式
    * 各種言語(('note:（これから広く使われているはず）'))
  * Feather形式
    * Python・R専用
  * Parquet形式
    * 各種言語(('note:（Hadoop界隈ですでに広く使われている）'))

= 多次元配列

  * Arrowではオプション機能
    * テンソルと呼んでいる\n
      (('note:（traditional multidimensional array objectと説明）'))
  * C++実装ではサポート
    * バインディングでは使える
    * Python・Ruby…では使える

= Tensor：Python

  # coderay python
  # NumPyでデータ生成→書き込み
  import pyarrow as pa
  import numpy as np

  ndarray = np.random.randn(10, 6) # 10x6
  print(ndarray)
  tensor = pa.Tensor.from_numpy(ndarray)
  with pa.OSFile("/tmp/tensor.arrow", "wb") as sink:
      pa.write_tensor(tensor, sink)

= Tensor：Ruby

  # coderay ruby
  # Rubyで読み込み
  require "arrow"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/tensor.arrow") do |input|
    tensor = input.read_tensor(0)
    p tensor.shape # => [10, 6]
  end

= Ruby：GSL

  # coderay ruby
  # GSLオブジェクトに変換
  require "arrow"
  require "arrow-gsl"
  require "pp"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/tensor.arrow") do |input|
    tensor = input.read_tensor(0)
    pp tensor.to_gsl
    # tensor.to_gsl.to_arrow == tensor
  end

= Ruby：NMatrix

  # coderay ruby
  # NMatrixオブジェクトに変換
  require "arrow"
  require "arrow-nmatrix"
  require "pp"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/tensor.arrow") do |input|
    tensor = input.read_tensor(0)
    pp tensor.to_nmatrix
    # tensor.to_nmatrix.to_arrow == tensor
  end

= Ruby：Numo::NArray

  # coderay ruby
  # Numo::NArrayオブジェクトに変換
  require "arrow"
  require "arrow-numo-narray"
  require "pp"

  Input = Arrow::MemoryMappedInputStream
  Input.open("/tmp/tensor.arrow") do |input|
    tensor = input.read_tensor(0)
    pp tensor.to_narray
    # tensor.to_narray.to_arrow == tensor
  end

= ここまでのまとめ1

  * Arrowが実現したい世界
    * データ交換コストが低い世界
    * 最適化実装を共有している世界

= ここまでのまとめ2

  * RubyとArrowの今
    * ArrowはRubyを公式サポート！
    * Rubyの外の世界とデータ交換可能\n
      (('note:（Arrow・Feather・Parquetをサポート）'))
    * Rubyの各種ライブラリーとの\n
      相互変換が可能\n
      (('note:（メモリーコピーぐらいのコストで）'))

= ArrowとRubyとこれから

  * Arrow
    * データフレーム処理の最適化実装
    * マルチコア対応
    * GPU対応
  * Ruby
    * Red Data Toolsプロジェクト

= Red Data Tools

  * Rubyでデータ処理したいなぁ！\n
    実現を目指すプロジェクト
  * URL：
    * https://github.io/red-data-tools
    * https://red-data-tools.github.io
    * https://gitter.im/red-data-tools

= 既存プロダクト

  * Red Arrow(('note:（ArrowのRubyバインディング）'))
    * Red Arrow XXX(('note:（ArrowとXXXの相互変換）'))
  * Parquet GLib(('note:（ParquetのGLibバインディング）'))
  * Red Parquet(('note:（ParquetのRubyバインディング）'))
  * Jekyll Jupyter Notebook plugin(('note:（JekyllでJupyter Notebookを表示）'))

= ポリシー

  * Acting than blaming\n
    (('note:時間は嘆き・非難より手を動かすことに使う'))
  * Continuous small works than a temporary big work than\n
    (('note:一時的な集中じゃなく小さくても継続して活動する'))
  * Ignore blames from outsiders\n
    (('note:部外者の非難は気にしない'))\n
    (('note:結果がでるまでグチグチ言われるはず :p'))
  * Fun! (Because we use Ruby!)

= Join Us!

  * Rubyでデータ処理したい人！
  * ポリシーに同意できる人！\n
    (('note:（手を動かす人！継続する人！楽しんでやる人！）'))
  * URL：
    * https://github.io/red-data-tools
    * https://red-data-tools.github.io
    * https://gitter.im/red-data-tools
